{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\ASUS\\\\OneDrive\\\\Desktop\\\\react\\\\project1\\\\src\\\\components\\\\PrismaticBurst.jsx\",\n  _s = $RefreshSig$();\nimport { useEffect, useRef } from 'react';\nimport { Renderer, Program, Mesh, Triangle, Texture } from 'ogl';\nimport '<div styleName={} />styles/PrismaticBurst.css';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst vertexShader = `#version 300 es\nin vec2 position;\nin vec2 uv;\nout vec2 vUv;\nvoid main() {\n    vUv = uv;\n    gl_Position = vec4(position, 0.0, 1.0);\n}\n`;\nconst fragmentShader = `#version 300 es\nprecision highp float;\nprecision highp int;\n\nout vec4 fragColor;\n\nuniform vec2  uResolution;\nuniform float uTime;\n\nuniform float uIntensity;\nuniform float uSpeed;\nuniform int   uAnimType;\nuniform vec2  uMouse;\nuniform int   uColorCount;\nuniform float uDistort;\nuniform vec2  uOffset;\nuniform sampler2D uGradient;\nuniform float uNoiseAmount;\nuniform int   uRayCount;\n\nfloat hash21(vec2 p){\n    p = floor(p);\n    float f = 52.9829189 * fract(dot(p, vec2(0.065, 0.005)));\n    return fract(f);\n}\n\nmat2 rot30(){ return mat2(0.8, -0.5, 0.5, 0.8); }\n\nfloat layeredNoise(vec2 fragPx){\n    vec2 p = mod(fragPx + vec2(uTime * 30.0, -uTime * 21.0), 1024.0);\n    vec2 q = rot30() * p;\n    float n = 0.0;\n    n += 0.40 * hash21(q);\n    n += 0.25 * hash21(q * 2.0 + 17.0);\n    n += 0.20 * hash21(q * 4.0 + 47.0);\n    n += 0.10 * hash21(q * 8.0 + 113.0);\n    n += 0.05 * hash21(q * 16.0 + 191.0);\n    return n;\n}\n\nvec3 rayDir(vec2 frag, vec2 res, vec2 offset, float dist){\n    float focal = res.y * max(dist, 1e-3);\n    return normalize(vec3(2.0 * (frag - offset) - res, focal));\n}\n\nfloat edgeFade(vec2 frag, vec2 res, vec2 offset){\n    vec2 toC = frag - 0.5 * res - offset;\n    float r = length(toC) / (0.5 * min(res.x, res.y));\n    float x = clamp(r, 0.0, 1.0);\n    float q = x * x * x * (x * (x * 6.0 - 15.0) + 10.0);\n    float s = q * 0.5;\n    s = pow(s, 1.5);\n    float tail = 1.0 - pow(1.0 - s, 2.0);\n    s = mix(s, tail, 0.2);\n    float dn = (layeredNoise(frag * 0.15) - 0.5) * 0.0015 * s;\n    return clamp(s + dn, 0.0, 1.0);\n}\n\nmat3 rotX(float a){ float c = cos(a), s = sin(a); return mat3(1.0,0.0,0.0, 0.0,c,-s, 0.0,s,c); }\nmat3 rotY(float a){ float c = cos(a), s = sin(a); return mat3(c,0.0,s, 0.0,1.0,0.0, -s,0.0,c); }\nmat3 rotZ(float a){ float c = cos(a), s = sin(a); return mat3(c,-s,0.0, s,c,0.0, 0.0,0.0,1.0); }\n\nvec3 sampleGradient(float t){\n    t = clamp(t, 0.0, 1.0);\n    return texture(uGradient, vec2(t, 0.5)).rgb;\n}\n\nvec2 rot2(vec2 v, float a){\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c) * v;\n}\n\nfloat bendAngle(vec3 q, float t){\n    float a = 0.8 * sin(q.x * 0.55 + t * 0.6)\n            + 0.7 * sin(q.y * 0.50 - t * 0.5)\n            + 0.6 * sin(q.z * 0.60 + t * 0.7);\n    return a;\n}\n\nvoid main(){\n    vec2 frag = gl_FragCoord.xy;\n    float t = uTime * uSpeed;\n    float jitterAmp = 0.1 * clamp(uNoiseAmount, 0.0, 1.0);\n    vec3 dir = rayDir(frag, uResolution, uOffset, 1.0);\n    float marchT = 0.0;\n    vec3 col = vec3(0.0);\n    float n = layeredNoise(frag);\n    vec4 c = cos(t * 0.2 + vec4(0.0, 33.0, 11.0, 0.0));\n    mat2 M2 = mat2(c.x, c.y, c.z, c.w);\n    float amp = clamp(uDistort, 0.0, 50.0) * 0.15;\n\n    mat3 rot3dMat = mat3(1.0);\n    if(uAnimType == 1){\n      vec3 ang = vec3(t * 0.31, t * 0.21, t * 0.17);\n      rot3dMat = rotZ(ang.z) * rotY(ang.y) * rotX(ang.x);\n    }\n    mat3 hoverMat = mat3(1.0);\n    if(uAnimType == 2){\n      vec2 m = uMouse * 2.0 - 1.0;\n      vec3 ang = vec3(m.y * 0.6, m.x * 0.6, 0.0);\n      hoverMat = rotY(ang.y) * rotX(ang.x);\n    }\n\n    for (int i = 0; i < 44; ++i) {\n        vec3 P = marchT * dir;\n        P.z -= 2.0;\n        float rad = length(P);\n        vec3 Pl = P * (10.0 / max(rad, 1e-6));\n\n        if(uAnimType == 0){\n            Pl.xz *= M2;\n        } else if(uAnimType == 1){\n      Pl = rot3dMat * Pl;\n        } else {\n      Pl = hoverMat * Pl;\n        }\n\n        float stepLen = min(rad - 0.3, n * jitterAmp) + 0.1;\n\n        float grow = smoothstep(0.35, 3.0, marchT);\n        float a1 = amp * grow * bendAngle(Pl * 0.6, t);\n        float a2 = 0.5 * amp * grow * bendAngle(Pl.zyx * 0.5 + 3.1, t * 0.9);\n        vec3 Pb = Pl;\n        Pb.xz = rot2(Pb.xz, a1);\n        Pb.xy = rot2(Pb.xy, a2);\n\n        float rayPattern = smoothstep(\n            0.5, 0.7,\n            sin(Pb.x + cos(Pb.y) * cos(Pb.z)) *\n            sin(Pb.z + sin(Pb.y) * cos(Pb.x + t))\n        );\n\n        if (uRayCount > 0) {\n            float ang = atan(Pb.y, Pb.x);\n            float comb = 0.5 + 0.5 * cos(float(uRayCount) * ang);\n            comb = pow(comb, 3.0);\n            rayPattern *= smoothstep(0.15, 0.95, comb);\n        }\n\n        vec3 spectralDefault = 1.0 + vec3(\n            cos(marchT * 3.0 + 0.0),\n            cos(marchT * 3.0 + 1.0),\n            cos(marchT * 3.0 + 2.0)\n        );\n\n        float saw = fract(marchT * 0.25);\n        float tRay = saw * saw * (3.0 - 2.0 * saw);\n        vec3 userGradient = 2.0 * sampleGradient(tRay);\n        vec3 spectral = (uColorCount > 0) ? userGradient : spectralDefault;\n        vec3 base = (0.05 / (0.4 + stepLen))\n                  * smoothstep(5.0, 0.0, rad)\n                  * spectral;\n\n        col += base * rayPattern;\n        marchT += stepLen;\n    }\n\n    col *= edgeFade(frag, uResolution, uOffset);\n    col *= uIntensity;\n\n    fragColor = vec4(clamp(col, 0.0, 1.0), 1.0);\n}`;\nconst hexToRgb01 = hex => {\n  let h = hex.trim();\n  if (h.startsWith('#')) h = h.slice(1);\n  if (h.length === 3) {\n    const r = h[0],\n      g = h[1],\n      b = h[2];\n    h = r + r + g + g + b + b;\n  }\n  const intVal = parseInt(h, 16);\n  if (isNaN(intVal) || h.length !== 6 && h.length !== 8) return [1, 1, 1];\n  const r = (intVal >> 16 & 255) / 255;\n  const g = (intVal >> 8 & 255) / 255;\n  const b = (intVal & 255) / 255;\n  return [r, g, b];\n};\nconst toPx = v => {\n  if (v == null) return 0;\n  if (typeof v === 'number') return v;\n  const s = String(v).trim();\n  const num = parseFloat(s.replace('px', ''));\n  return isNaN(num) ? 0 : num;\n};\nconst PrismaticBurst = ({\n  intensity = 2,\n  speed = 0.5,\n  animationType = 'rotate3d',\n  colors,\n  distort = 0,\n  paused = false,\n  offset = {\n    x: 0,\n    y: 0\n  },\n  hoverDampness = 0,\n  rayCount,\n  mixBlendMode = 'lighten'\n}) => {\n  _s();\n  const containerRef = useRef(null);\n  const programRef = useRef(null);\n  const rendererRef = useRef(null);\n  const mouseTargetRef = useRef([0.5, 0.5]);\n  const mouseSmoothRef = useRef([0.5, 0.5]);\n  const pausedRef = useRef(paused);\n  const gradTexRef = useRef(null);\n  const hoverDampRef = useRef(hoverDampness);\n  const isVisibleRef = useRef(true);\n  const meshRef = useRef(null);\n  const triRef = useRef(null);\n  useEffect(() => {\n    pausedRef.current = paused;\n  }, [paused]);\n  useEffect(() => {\n    hoverDampRef.current = hoverDampness;\n  }, [hoverDampness]);\n  useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n    const dpr = Math.min(window.devicePixelRatio || 1, 2);\n    const renderer = new Renderer({\n      dpr,\n      alpha: false,\n      antialias: false\n    });\n    rendererRef.current = renderer;\n    const gl = renderer.gl;\n    gl.canvas.style.position = 'absolute';\n    gl.canvas.style.inset = '0';\n    gl.canvas.style.width = '100%';\n    gl.canvas.style.height = '100%';\n    gl.canvas.style.mixBlendMode = mixBlendMode && mixBlendMode !== 'none' ? mixBlendMode : '';\n    container.appendChild(gl.canvas);\n    const white = new Uint8Array([255, 255, 255, 255]);\n    const gradientTex = new Texture(gl, {\n      image: white,\n      width: 1,\n      height: 1,\n      generateMipmaps: false,\n      flipY: false\n    });\n    gradientTex.minFilter = gl.LINEAR;\n    gradientTex.magFilter = gl.LINEAR;\n    gradientTex.wrapS = gl.CLAMP_TO_EDGE;\n    gradientTex.wrapT = gl.CLAMP_TO_EDGE;\n    gradTexRef.current = gradientTex;\n    const program = new Program(gl, {\n      vertex: vertexShader,\n      fragment: fragmentShader,\n      uniforms: {\n        uResolution: {\n          value: [1, 1]\n        },\n        uTime: {\n          value: 0\n        },\n        uIntensity: {\n          value: 1\n        },\n        uSpeed: {\n          value: 1\n        },\n        uAnimType: {\n          value: 0\n        },\n        uMouse: {\n          value: [0.5, 0.5]\n        },\n        uColorCount: {\n          value: 0\n        },\n        uDistort: {\n          value: 0\n        },\n        uOffset: {\n          value: [0, 0]\n        },\n        uGradient: {\n          value: gradientTex\n        },\n        uNoiseAmount: {\n          value: 0.8\n        },\n        uRayCount: {\n          value: 0\n        }\n      }\n    });\n    programRef.current = program;\n    const triangle = new Triangle(gl);\n    const mesh = new Mesh(gl, {\n      geometry: triangle,\n      program\n    });\n    triRef.current = triangle;\n    meshRef.current = mesh;\n    const resize = () => {\n      const w = container.clientWidth || 1;\n      const h = container.clientHeight || 1;\n      renderer.setSize(w, h);\n      program.uniforms.uResolution.value = [gl.drawingBufferWidth, gl.drawingBufferHeight];\n    };\n    let ro = null;\n    if ('ResizeObserver' in window) {\n      ro = new ResizeObserver(resize);\n      ro.observe(container);\n    } else {\n      window.addEventListener('resize', resize);\n    }\n    resize();\n    const onPointer = e => {\n      const rect = container.getBoundingClientRect();\n      const x = (e.clientX - rect.left) / Math.max(rect.width, 1);\n      const y = (e.clientY - rect.top) / Math.max(rect.height, 1);\n      mouseTargetRef.current = [Math.min(Math.max(x, 0), 1), Math.min(Math.max(y, 0), 1)];\n    };\n    container.addEventListener('pointermove', onPointer, {\n      passive: true\n    });\n    let io = null;\n    if ('IntersectionObserver' in window) {\n      io = new IntersectionObserver(entries => {\n        if (entries[0]) {\n          isVisibleRef.current = entries[0].isIntersecting;\n        }\n      }, {\n        root: null,\n        threshold: 0.01\n      });\n      io.observe(container);\n    }\n    const onVis = () => {};\n    document.addEventListener('visibilitychange', onVis);\n    let raf = 0;\n    let last = performance.now();\n    let accumTime = 0;\n    const update = now => {\n      const dt = Math.max(0, now - last) * 0.001;\n      last = now;\n      const visible = isVisibleRef.current && !document.hidden;\n      if (!pausedRef.current) accumTime += dt;\n      if (!visible) {\n        raf = requestAnimationFrame(update);\n        return;\n      }\n      const tau = 0.02 + Math.max(0, Math.min(1, hoverDampRef.current)) * 0.5;\n      const alpha = 1 - Math.exp(-dt / tau);\n      const tgt = mouseTargetRef.current;\n      const sm = mouseSmoothRef.current;\n      sm[0] += (tgt[0] - sm[0]) * alpha;\n      sm[1] += (tgt[1] - sm[1]) * alpha;\n      program.uniforms.uMouse.value = sm;\n      program.uniforms.uTime.value = accumTime;\n      renderer.render({\n        scene: meshRef.current\n      });\n      raf = requestAnimationFrame(update);\n    };\n    raf = requestAnimationFrame(update);\n    return () => {\n      var _ro, _io;\n      cancelAnimationFrame(raf);\n      container.removeEventListener('pointermove', onPointer);\n      (_ro = ro) === null || _ro === void 0 ? void 0 : _ro.disconnect();\n      if (!ro) window.removeEventListener('resize', resize);\n      (_io = io) === null || _io === void 0 ? void 0 : _io.disconnect();\n      document.removeEventListener('visibilitychange', onVis);\n      try {\n        container.removeChild(gl.canvas);\n      } catch {\n        console.warn('Canvas already removed');\n      }\n      try {\n        var _meshRef$current, _meshRef$current$remo;\n        (_meshRef$current = meshRef.current) === null || _meshRef$current === void 0 ? void 0 : (_meshRef$current$remo = _meshRef$current.remove) === null || _meshRef$current$remo === void 0 ? void 0 : _meshRef$current$remo.call(_meshRef$current);\n      } catch (e) {\n        /* ignore dispose errors */\n      }\n      try {\n        var _triRef$current, _triRef$current$remov;\n        (_triRef$current = triRef.current) === null || _triRef$current === void 0 ? void 0 : (_triRef$current$remov = _triRef$current.remove) === null || _triRef$current$remov === void 0 ? void 0 : _triRef$current$remov.call(_triRef$current);\n      } catch (e) {\n        /* ignore dispose errors */\n      }\n      try {\n        var _programRef$current, _programRef$current$r;\n        (_programRef$current = programRef.current) === null || _programRef$current === void 0 ? void 0 : (_programRef$current$r = _programRef$current.remove) === null || _programRef$current$r === void 0 ? void 0 : _programRef$current$r.call(_programRef$current);\n      } catch (e) {\n        /* ignore dispose errors */\n      }\n      try {\n        var _rendererRef$current, _gradTexRef$current;\n        const glCtx = (_rendererRef$current = rendererRef.current) === null || _rendererRef$current === void 0 ? void 0 : _rendererRef$current.gl;\n        if (glCtx && (_gradTexRef$current = gradTexRef.current) !== null && _gradTexRef$current !== void 0 && _gradTexRef$current.texture) {\n          glCtx.deleteTexture(gradTexRef.current.texture);\n        }\n      } catch (e) {\n        /* ignore texture delete errors */\n      }\n      programRef.current = null;\n      rendererRef.current = null;\n      gradTexRef.current = null;\n      meshRef.current = null;\n      triRef.current = null;\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  useEffect(() => {\n    var _rendererRef$current2, _rendererRef$current3;\n    const canvas = (_rendererRef$current2 = rendererRef.current) === null || _rendererRef$current2 === void 0 ? void 0 : (_rendererRef$current3 = _rendererRef$current2.gl) === null || _rendererRef$current3 === void 0 ? void 0 : _rendererRef$current3.canvas;\n    if (canvas) {\n      canvas.style.mixBlendMode = mixBlendMode && mixBlendMode !== 'none' ? mixBlendMode : '';\n    }\n  }, [mixBlendMode]);\n  useEffect(() => {\n    const program = programRef.current;\n    const renderer = rendererRef.current;\n    const gradTex = gradTexRef.current;\n    if (!program || !renderer || !gradTex) return;\n    program.uniforms.uIntensity.value = intensity !== null && intensity !== void 0 ? intensity : 1;\n    program.uniforms.uSpeed.value = speed !== null && speed !== void 0 ? speed : 1;\n    const animTypeMap = {\n      rotate: 0,\n      rotate3d: 1,\n      hover: 2\n    };\n    program.uniforms.uAnimType.value = animTypeMap[animationType !== null && animationType !== void 0 ? animationType : 'rotate'];\n    program.uniforms.uDistort.value = typeof distort === 'number' ? distort : 0;\n    const ox = toPx(offset === null || offset === void 0 ? void 0 : offset.x);\n    const oy = toPx(offset === null || offset === void 0 ? void 0 : offset.y);\n    program.uniforms.uOffset.value = [ox, oy];\n    program.uniforms.uRayCount.value = Math.max(0, Math.floor(rayCount !== null && rayCount !== void 0 ? rayCount : 0));\n    let count = 0;\n    if (Array.isArray(colors) && colors.length > 0) {\n      const gl = renderer.gl;\n      const capped = colors.slice(0, 64);\n      count = capped.length;\n      const data = new Uint8Array(count * 4);\n      for (let i = 0; i < count; i++) {\n        const [r, g, b] = hexToRgb01(capped[i]);\n        data[i * 4 + 0] = Math.round(r * 255);\n        data[i * 4 + 1] = Math.round(g * 255);\n        data[i * 4 + 2] = Math.round(b * 255);\n        data[i * 4 + 3] = 255;\n      }\n      gradTex.image = data;\n      gradTex.width = count;\n      gradTex.height = 1;\n      gradTex.minFilter = gl.LINEAR;\n      gradTex.magFilter = gl.LINEAR;\n      gradTex.wrapS = gl.CLAMP_TO_EDGE;\n      gradTex.wrapT = gl.CLAMP_TO_EDGE;\n      gradTex.flipY = false;\n      gradTex.generateMipmaps = false;\n      gradTex.format = gl.RGBA;\n      gradTex.type = gl.UNSIGNED_BYTE;\n      gradTex.needsUpdate = true;\n    } else {\n      count = 0;\n    }\n    program.uniforms.uColorCount.value = count;\n  }, [intensity, speed, animationType, colors, distort, offset, rayCount]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"prismatic-burst-container\",\n    ref: containerRef\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 472,\n    columnNumber: 10\n  }, this);\n};\n_s(PrismaticBurst, \"8zuKxmbDSzrr+H1RplqTsKMvmdo=\");\n_c = PrismaticBurst;\nexport default PrismaticBurst;\nvar _c;\n$RefreshReg$(_c, \"PrismaticBurst\");","map":{"version":3,"names":["useEffect","useRef","Renderer","Program","Mesh","Triangle","Texture","jsxDEV","_jsxDEV","vertexShader","fragmentShader","hexToRgb01","hex","h","trim","startsWith","slice","length","r","g","b","intVal","parseInt","isNaN","toPx","v","s","String","num","parseFloat","replace","PrismaticBurst","intensity","speed","animationType","colors","distort","paused","offset","x","y","hoverDampness","rayCount","mixBlendMode","_s","containerRef","programRef","rendererRef","mouseTargetRef","mouseSmoothRef","pausedRef","gradTexRef","hoverDampRef","isVisibleRef","meshRef","triRef","current","container","dpr","Math","min","window","devicePixelRatio","renderer","alpha","antialias","gl","canvas","style","position","inset","width","height","appendChild","white","Uint8Array","gradientTex","image","generateMipmaps","flipY","minFilter","LINEAR","magFilter","wrapS","CLAMP_TO_EDGE","wrapT","program","vertex","fragment","uniforms","uResolution","value","uTime","uIntensity","uSpeed","uAnimType","uMouse","uColorCount","uDistort","uOffset","uGradient","uNoiseAmount","uRayCount","triangle","mesh","geometry","resize","w","clientWidth","clientHeight","setSize","drawingBufferWidth","drawingBufferHeight","ro","ResizeObserver","observe","addEventListener","onPointer","e","rect","getBoundingClientRect","clientX","left","max","clientY","top","passive","io","IntersectionObserver","entries","isIntersecting","root","threshold","onVis","document","raf","last","performance","now","accumTime","update","dt","visible","hidden","requestAnimationFrame","tau","exp","tgt","sm","render","scene","_ro","_io","cancelAnimationFrame","removeEventListener","disconnect","removeChild","console","warn","_meshRef$current","_meshRef$current$remo","remove","call","_triRef$current","_triRef$current$remov","_programRef$current","_programRef$current$r","_rendererRef$current","_gradTexRef$current","glCtx","texture","deleteTexture","_rendererRef$current2","_rendererRef$current3","gradTex","animTypeMap","rotate","rotate3d","hover","ox","oy","floor","count","Array","isArray","capped","data","i","round","format","RGBA","type","UNSIGNED_BYTE","needsUpdate","className","ref","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/ASUS/OneDrive/Desktop/react/project1/src/components/PrismaticBurst.jsx"],"sourcesContent":["import { useEffect, useRef } from 'react';\r\nimport { Renderer, Program, Mesh, Triangle, Texture } from 'ogl';\r\nimport '<div styleName={} />styles/PrismaticBurst.css';\r\n\r\nconst vertexShader = `#version 300 es\r\nin vec2 position;\r\nin vec2 uv;\r\nout vec2 vUv;\r\nvoid main() {\r\n    vUv = uv;\r\n    gl_Position = vec4(position, 0.0, 1.0);\r\n}\r\n`;\r\n\r\nconst fragmentShader = `#version 300 es\r\nprecision highp float;\r\nprecision highp int;\r\n\r\nout vec4 fragColor;\r\n\r\nuniform vec2  uResolution;\r\nuniform float uTime;\r\n\r\nuniform float uIntensity;\r\nuniform float uSpeed;\r\nuniform int   uAnimType;\r\nuniform vec2  uMouse;\r\nuniform int   uColorCount;\r\nuniform float uDistort;\r\nuniform vec2  uOffset;\r\nuniform sampler2D uGradient;\r\nuniform float uNoiseAmount;\r\nuniform int   uRayCount;\r\n\r\nfloat hash21(vec2 p){\r\n    p = floor(p);\r\n    float f = 52.9829189 * fract(dot(p, vec2(0.065, 0.005)));\r\n    return fract(f);\r\n}\r\n\r\nmat2 rot30(){ return mat2(0.8, -0.5, 0.5, 0.8); }\r\n\r\nfloat layeredNoise(vec2 fragPx){\r\n    vec2 p = mod(fragPx + vec2(uTime * 30.0, -uTime * 21.0), 1024.0);\r\n    vec2 q = rot30() * p;\r\n    float n = 0.0;\r\n    n += 0.40 * hash21(q);\r\n    n += 0.25 * hash21(q * 2.0 + 17.0);\r\n    n += 0.20 * hash21(q * 4.0 + 47.0);\r\n    n += 0.10 * hash21(q * 8.0 + 113.0);\r\n    n += 0.05 * hash21(q * 16.0 + 191.0);\r\n    return n;\r\n}\r\n\r\nvec3 rayDir(vec2 frag, vec2 res, vec2 offset, float dist){\r\n    float focal = res.y * max(dist, 1e-3);\r\n    return normalize(vec3(2.0 * (frag - offset) - res, focal));\r\n}\r\n\r\nfloat edgeFade(vec2 frag, vec2 res, vec2 offset){\r\n    vec2 toC = frag - 0.5 * res - offset;\r\n    float r = length(toC) / (0.5 * min(res.x, res.y));\r\n    float x = clamp(r, 0.0, 1.0);\r\n    float q = x * x * x * (x * (x * 6.0 - 15.0) + 10.0);\r\n    float s = q * 0.5;\r\n    s = pow(s, 1.5);\r\n    float tail = 1.0 - pow(1.0 - s, 2.0);\r\n    s = mix(s, tail, 0.2);\r\n    float dn = (layeredNoise(frag * 0.15) - 0.5) * 0.0015 * s;\r\n    return clamp(s + dn, 0.0, 1.0);\r\n}\r\n\r\nmat3 rotX(float a){ float c = cos(a), s = sin(a); return mat3(1.0,0.0,0.0, 0.0,c,-s, 0.0,s,c); }\r\nmat3 rotY(float a){ float c = cos(a), s = sin(a); return mat3(c,0.0,s, 0.0,1.0,0.0, -s,0.0,c); }\r\nmat3 rotZ(float a){ float c = cos(a), s = sin(a); return mat3(c,-s,0.0, s,c,0.0, 0.0,0.0,1.0); }\r\n\r\nvec3 sampleGradient(float t){\r\n    t = clamp(t, 0.0, 1.0);\r\n    return texture(uGradient, vec2(t, 0.5)).rgb;\r\n}\r\n\r\nvec2 rot2(vec2 v, float a){\r\n    float s = sin(a), c = cos(a);\r\n    return mat2(c, -s, s, c) * v;\r\n}\r\n\r\nfloat bendAngle(vec3 q, float t){\r\n    float a = 0.8 * sin(q.x * 0.55 + t * 0.6)\r\n            + 0.7 * sin(q.y * 0.50 - t * 0.5)\r\n            + 0.6 * sin(q.z * 0.60 + t * 0.7);\r\n    return a;\r\n}\r\n\r\nvoid main(){\r\n    vec2 frag = gl_FragCoord.xy;\r\n    float t = uTime * uSpeed;\r\n    float jitterAmp = 0.1 * clamp(uNoiseAmount, 0.0, 1.0);\r\n    vec3 dir = rayDir(frag, uResolution, uOffset, 1.0);\r\n    float marchT = 0.0;\r\n    vec3 col = vec3(0.0);\r\n    float n = layeredNoise(frag);\r\n    vec4 c = cos(t * 0.2 + vec4(0.0, 33.0, 11.0, 0.0));\r\n    mat2 M2 = mat2(c.x, c.y, c.z, c.w);\r\n    float amp = clamp(uDistort, 0.0, 50.0) * 0.15;\r\n\r\n    mat3 rot3dMat = mat3(1.0);\r\n    if(uAnimType == 1){\r\n      vec3 ang = vec3(t * 0.31, t * 0.21, t * 0.17);\r\n      rot3dMat = rotZ(ang.z) * rotY(ang.y) * rotX(ang.x);\r\n    }\r\n    mat3 hoverMat = mat3(1.0);\r\n    if(uAnimType == 2){\r\n      vec2 m = uMouse * 2.0 - 1.0;\r\n      vec3 ang = vec3(m.y * 0.6, m.x * 0.6, 0.0);\r\n      hoverMat = rotY(ang.y) * rotX(ang.x);\r\n    }\r\n\r\n    for (int i = 0; i < 44; ++i) {\r\n        vec3 P = marchT * dir;\r\n        P.z -= 2.0;\r\n        float rad = length(P);\r\n        vec3 Pl = P * (10.0 / max(rad, 1e-6));\r\n\r\n        if(uAnimType == 0){\r\n            Pl.xz *= M2;\r\n        } else if(uAnimType == 1){\r\n      Pl = rot3dMat * Pl;\r\n        } else {\r\n      Pl = hoverMat * Pl;\r\n        }\r\n\r\n        float stepLen = min(rad - 0.3, n * jitterAmp) + 0.1;\r\n\r\n        float grow = smoothstep(0.35, 3.0, marchT);\r\n        float a1 = amp * grow * bendAngle(Pl * 0.6, t);\r\n        float a2 = 0.5 * amp * grow * bendAngle(Pl.zyx * 0.5 + 3.1, t * 0.9);\r\n        vec3 Pb = Pl;\r\n        Pb.xz = rot2(Pb.xz, a1);\r\n        Pb.xy = rot2(Pb.xy, a2);\r\n\r\n        float rayPattern = smoothstep(\r\n            0.5, 0.7,\r\n            sin(Pb.x + cos(Pb.y) * cos(Pb.z)) *\r\n            sin(Pb.z + sin(Pb.y) * cos(Pb.x + t))\r\n        );\r\n\r\n        if (uRayCount > 0) {\r\n            float ang = atan(Pb.y, Pb.x);\r\n            float comb = 0.5 + 0.5 * cos(float(uRayCount) * ang);\r\n            comb = pow(comb, 3.0);\r\n            rayPattern *= smoothstep(0.15, 0.95, comb);\r\n        }\r\n\r\n        vec3 spectralDefault = 1.0 + vec3(\r\n            cos(marchT * 3.0 + 0.0),\r\n            cos(marchT * 3.0 + 1.0),\r\n            cos(marchT * 3.0 + 2.0)\r\n        );\r\n\r\n        float saw = fract(marchT * 0.25);\r\n        float tRay = saw * saw * (3.0 - 2.0 * saw);\r\n        vec3 userGradient = 2.0 * sampleGradient(tRay);\r\n        vec3 spectral = (uColorCount > 0) ? userGradient : spectralDefault;\r\n        vec3 base = (0.05 / (0.4 + stepLen))\r\n                  * smoothstep(5.0, 0.0, rad)\r\n                  * spectral;\r\n\r\n        col += base * rayPattern;\r\n        marchT += stepLen;\r\n    }\r\n\r\n    col *= edgeFade(frag, uResolution, uOffset);\r\n    col *= uIntensity;\r\n\r\n    fragColor = vec4(clamp(col, 0.0, 1.0), 1.0);\r\n}`;\r\n\r\nconst hexToRgb01 = hex => {\r\n  let h = hex.trim();\r\n  if (h.startsWith('#')) h = h.slice(1);\r\n  if (h.length === 3) {\r\n    const r = h[0],\r\n      g = h[1],\r\n      b = h[2];\r\n    h = r + r + g + g + b + b;\r\n  }\r\n  const intVal = parseInt(h, 16);\r\n  if (isNaN(intVal) || (h.length !== 6 && h.length !== 8)) return [1, 1, 1];\r\n  const r = ((intVal >> 16) & 255) / 255;\r\n  const g = ((intVal >> 8) & 255) / 255;\r\n  const b = (intVal & 255) / 255;\r\n  return [r, g, b];\r\n};\r\n\r\nconst toPx = v => {\r\n  if (v == null) return 0;\r\n  if (typeof v === 'number') return v;\r\n  const s = String(v).trim();\r\n  const num = parseFloat(s.replace('px', ''));\r\n  return isNaN(num) ? 0 : num;\r\n};\r\n\r\nconst PrismaticBurst = ({\r\n  intensity = 2,\r\n  speed = 0.5,\r\n  animationType = 'rotate3d',\r\n  colors,\r\n  distort = 0,\r\n  paused = false,\r\n  offset = { x: 0, y: 0 },\r\n  hoverDampness = 0,\r\n  rayCount,\r\n  mixBlendMode = 'lighten'\r\n}) => {\r\n  const containerRef = useRef(null);\r\n  const programRef = useRef(null);\r\n  const rendererRef = useRef(null);\r\n  const mouseTargetRef = useRef([0.5, 0.5]);\r\n  const mouseSmoothRef = useRef([0.5, 0.5]);\r\n  const pausedRef = useRef(paused);\r\n  const gradTexRef = useRef(null);\r\n  const hoverDampRef = useRef(hoverDampness);\r\n  const isVisibleRef = useRef(true);\r\n  const meshRef = useRef(null);\r\n  const triRef = useRef(null);\r\n\r\n  useEffect(() => {\r\n    pausedRef.current = paused;\r\n  }, [paused]);\r\n  useEffect(() => {\r\n    hoverDampRef.current = hoverDampness;\r\n  }, [hoverDampness]);\r\n\r\n  useEffect(() => {\r\n    const container = containerRef.current;\r\n    if (!container) return;\r\n\r\n    const dpr = Math.min(window.devicePixelRatio || 1, 2);\r\n    const renderer = new Renderer({\r\n      dpr,\r\n      alpha: false,\r\n      antialias: false\r\n    });\r\n    rendererRef.current = renderer;\r\n\r\n    const gl = renderer.gl;\r\n    gl.canvas.style.position = 'absolute';\r\n    gl.canvas.style.inset = '0';\r\n    gl.canvas.style.width = '100%';\r\n    gl.canvas.style.height = '100%';\r\n    gl.canvas.style.mixBlendMode = mixBlendMode && mixBlendMode !== 'none' ? mixBlendMode : '';\r\n    container.appendChild(gl.canvas);\r\n\r\n    const white = new Uint8Array([255, 255, 255, 255]);\r\n    const gradientTex = new Texture(gl, {\r\n      image: white,\r\n      width: 1,\r\n      height: 1,\r\n      generateMipmaps: false,\r\n      flipY: false\r\n    });\r\n\r\n    gradientTex.minFilter = gl.LINEAR;\r\n    gradientTex.magFilter = gl.LINEAR;\r\n    gradientTex.wrapS = gl.CLAMP_TO_EDGE;\r\n    gradientTex.wrapT = gl.CLAMP_TO_EDGE;\r\n    gradTexRef.current = gradientTex;\r\n\r\n    const program = new Program(gl, {\r\n      vertex: vertexShader,\r\n      fragment: fragmentShader,\r\n      uniforms: {\r\n        uResolution: { value: [1, 1] },\r\n        uTime: { value: 0 },\r\n\r\n        uIntensity: { value: 1 },\r\n        uSpeed: { value: 1 },\r\n        uAnimType: { value: 0 },\r\n        uMouse: { value: [0.5, 0.5] },\r\n        uColorCount: { value: 0 },\r\n        uDistort: { value: 0 },\r\n        uOffset: { value: [0, 0] },\r\n        uGradient: { value: gradientTex },\r\n        uNoiseAmount: { value: 0.8 },\r\n        uRayCount: { value: 0 }\r\n      }\r\n    });\r\n\r\n    programRef.current = program;\r\n\r\n    const triangle = new Triangle(gl);\r\n    const mesh = new Mesh(gl, { geometry: triangle, program });\r\n    triRef.current = triangle;\r\n    meshRef.current = mesh;\r\n\r\n    const resize = () => {\r\n      const w = container.clientWidth || 1;\r\n      const h = container.clientHeight || 1;\r\n      renderer.setSize(w, h);\r\n      program.uniforms.uResolution.value = [gl.drawingBufferWidth, gl.drawingBufferHeight];\r\n    };\r\n\r\n    let ro = null;\r\n    if ('ResizeObserver' in window) {\r\n      ro = new ResizeObserver(resize);\r\n      ro.observe(container);\r\n    } else {\r\n      window.addEventListener('resize', resize);\r\n    }\r\n    resize();\r\n\r\n    const onPointer = e => {\r\n      const rect = container.getBoundingClientRect();\r\n      const x = (e.clientX - rect.left) / Math.max(rect.width, 1);\r\n      const y = (e.clientY - rect.top) / Math.max(rect.height, 1);\r\n      mouseTargetRef.current = [Math.min(Math.max(x, 0), 1), Math.min(Math.max(y, 0), 1)];\r\n    };\r\n    container.addEventListener('pointermove', onPointer, { passive: true });\r\n\r\n    let io = null;\r\n    if ('IntersectionObserver' in window) {\r\n      io = new IntersectionObserver(\r\n        entries => {\r\n          if (entries[0]) {\r\n            isVisibleRef.current = entries[0].isIntersecting;\r\n          }\r\n        },\r\n        { root: null, threshold: 0.01 }\r\n      );\r\n      io.observe(container);\r\n    }\r\n\r\n    const onVis = () => {};\r\n    document.addEventListener('visibilitychange', onVis);\r\n\r\n    let raf = 0;\r\n    let last = performance.now();\r\n    let accumTime = 0;\r\n\r\n    const update = now => {\r\n      const dt = Math.max(0, now - last) * 0.001;\r\n      last = now;\r\n      const visible = isVisibleRef.current && !document.hidden;\r\n      if (!pausedRef.current) accumTime += dt;\r\n\r\n      if (!visible) {\r\n        raf = requestAnimationFrame(update);\r\n        return;\r\n      }\r\n\r\n      const tau = 0.02 + Math.max(0, Math.min(1, hoverDampRef.current)) * 0.5;\r\n      const alpha = 1 - Math.exp(-dt / tau);\r\n      const tgt = mouseTargetRef.current;\r\n      const sm = mouseSmoothRef.current;\r\n      sm[0] += (tgt[0] - sm[0]) * alpha;\r\n      sm[1] += (tgt[1] - sm[1]) * alpha;\r\n\r\n      program.uniforms.uMouse.value = sm;\r\n      program.uniforms.uTime.value = accumTime;\r\n\r\n      renderer.render({ scene: meshRef.current });\r\n      raf = requestAnimationFrame(update);\r\n    };\r\n    raf = requestAnimationFrame(update);\r\n\r\n    return () => {\r\n      cancelAnimationFrame(raf);\r\n      container.removeEventListener('pointermove', onPointer);\r\n      ro?.disconnect();\r\n      if (!ro) window.removeEventListener('resize', resize);\r\n      io?.disconnect();\r\n      document.removeEventListener('visibilitychange', onVis);\r\n      try {\r\n        container.removeChild(gl.canvas);\r\n      } catch {\r\n        console.warn('Canvas already removed');\r\n      }\r\n      try {\r\n        meshRef.current?.remove?.();\r\n      } catch (e) {\r\n        /* ignore dispose errors */\r\n      }\r\n      try {\r\n        triRef.current?.remove?.();\r\n      } catch (e) {\r\n        /* ignore dispose errors */\r\n      }\r\n      try {\r\n        programRef.current?.remove?.();\r\n      } catch (e) {\r\n        /* ignore dispose errors */\r\n      }\r\n      try {\r\n        const glCtx = rendererRef.current?.gl;\r\n        if (glCtx && gradTexRef.current?.texture) {\r\n          glCtx.deleteTexture(gradTexRef.current.texture);\r\n        }\r\n      } catch (e) {\r\n        /* ignore texture delete errors */\r\n      }\r\n      programRef.current = null;\r\n      rendererRef.current = null;\r\n      gradTexRef.current = null;\r\n      meshRef.current = null;\r\n      triRef.current = null;\r\n    };\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    const canvas = rendererRef.current?.gl?.canvas;\r\n\r\n    if (canvas) {\r\n      canvas.style.mixBlendMode = mixBlendMode && mixBlendMode !== 'none' ? mixBlendMode : '';\r\n    }\r\n  }, [mixBlendMode]);\r\n\r\n  useEffect(() => {\r\n    const program = programRef.current;\r\n    const renderer = rendererRef.current;\r\n    const gradTex = gradTexRef.current;\r\n    if (!program || !renderer || !gradTex) return;\r\n\r\n    program.uniforms.uIntensity.value = intensity ?? 1;\r\n    program.uniforms.uSpeed.value = speed ?? 1;\r\n\r\n    const animTypeMap = {\r\n      rotate: 0,\r\n      rotate3d: 1,\r\n      hover: 2\r\n    };\r\n    program.uniforms.uAnimType.value = animTypeMap[animationType ?? 'rotate'];\r\n\r\n    program.uniforms.uDistort.value = typeof distort === 'number' ? distort : 0;\r\n\r\n    const ox = toPx(offset?.x);\r\n    const oy = toPx(offset?.y);\r\n    program.uniforms.uOffset.value = [ox, oy];\r\n    program.uniforms.uRayCount.value = Math.max(0, Math.floor(rayCount ?? 0));\r\n\r\n    let count = 0;\r\n    if (Array.isArray(colors) && colors.length > 0) {\r\n      const gl = renderer.gl;\r\n      const capped = colors.slice(0, 64);\r\n      count = capped.length;\r\n      const data = new Uint8Array(count * 4);\r\n      for (let i = 0; i < count; i++) {\r\n        const [r, g, b] = hexToRgb01(capped[i]);\r\n        data[i * 4 + 0] = Math.round(r * 255);\r\n        data[i * 4 + 1] = Math.round(g * 255);\r\n        data[i * 4 + 2] = Math.round(b * 255);\r\n        data[i * 4 + 3] = 255;\r\n      }\r\n      gradTex.image = data;\r\n      gradTex.width = count;\r\n      gradTex.height = 1;\r\n      gradTex.minFilter = gl.LINEAR;\r\n      gradTex.magFilter = gl.LINEAR;\r\n      gradTex.wrapS = gl.CLAMP_TO_EDGE;\r\n      gradTex.wrapT = gl.CLAMP_TO_EDGE;\r\n      gradTex.flipY = false;\r\n      gradTex.generateMipmaps = false;\r\n      gradTex.format = gl.RGBA;\r\n      gradTex.type = gl.UNSIGNED_BYTE;\r\n      gradTex.needsUpdate = true;\r\n    } else {\r\n      count = 0;\r\n    }\r\n    program.uniforms.uColorCount.value = count;\r\n  }, [intensity, speed, animationType, colors, distort, offset, rayCount]);\r\n\r\n  return <div className=\"prismatic-burst-container\" ref={containerRef} />;\r\n};\r\n\r\nexport default PrismaticBurst;\r\n"],"mappings":";;AAAA,SAASA,SAAS,EAAEC,MAAM,QAAQ,OAAO;AACzC,SAASC,QAAQ,EAAEC,OAAO,EAAEC,IAAI,EAAEC,QAAQ,EAAEC,OAAO,QAAQ,KAAK;AAChE,OAAO,+CAA+C;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAEvD,MAAMC,YAAY,GAAG;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,MAAMC,cAAc,GAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AAEF,MAAMC,UAAU,GAAGC,GAAG,IAAI;EACxB,IAAIC,CAAC,GAAGD,GAAG,CAACE,IAAI,CAAC,CAAC;EAClB,IAAID,CAAC,CAACE,UAAU,CAAC,GAAG,CAAC,EAAEF,CAAC,GAAGA,CAAC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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}